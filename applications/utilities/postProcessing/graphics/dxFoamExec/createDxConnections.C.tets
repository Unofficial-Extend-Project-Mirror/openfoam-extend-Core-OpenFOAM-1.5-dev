/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright held by original author
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM; if not, write to the Free Software Foundation,
    Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

Description

    See README.

\*---------------------------------------------------------------------------*/

#include "dxFvMesh.H"
#include "foamValid.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

namespace Foam
{

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

DXArray dxFvMesh::createDxConnections()
{
    Info<< "dxFoamExec:dxFvMesh::createDxConnections : create DX connections"
        << endl;

    const cellModel& hex = *(cellModeller::lookup("hex"));
    const cellModel& wedge = *(cellModeller::lookup("wedge"));
    const cellModel& prism = *(cellModeller::lookup("prism"));
    const cellModel& pyr = *(cellModeller::lookup("pyr"));
    const cellModel& tet = *(cellModeller::lookup("tet"));
    const cellModel& tetWedge = *(cellModeller::lookup("tetWedge"));
    const cellModel& splitHex = *(cellModeller::lookup("splitHex"));

    const cellShapeList& cells = cellShapes();

    // Number of original cells in FOAM mesh
    label nOCells = nCells();

    // Number of additional points needed by the decomposition of polyhedra
    label nAddPoints = 0;

    // Number of additional cells generated by the decomposition of polyhedra
    label nAddCells = 0;

    // Scan for cells which need to be decomposed and count additional points
    // and cells

    forAll(cells, celli)
    {
        const cellModel& model = cells[celli].model();

        if 
        (
            model != hex
         && model != wedge
         && model != prism
         && model != pyr
         && model != tet
         && model != tetWedge
         && model != splitHex
        )
        {
            nAddPoints++;
            nAddCells += nTetsForCell(celli) - 1;
        }
    }


    // Scan boundary patches for the number of faces in the valid patches
    // and for additional faces generated by cell decomposition
    
    nBfaces_ = 0;
    label nAddBfaces = 0;

    const polyBoundaryMesh& patches = boundaryMesh();

    forAll (patches, patchi)
    {
        const polyPatch& faces = patches[patchi];

        if (valid(faces))
        {
            nBfaces_ += faces.size();

            forAll(faces, facei)
            {
                if (faces[facei].size() > 4)
                {
                    nAddBfaces += faces[facei].size() - 3;
                }
            }
        }
    }


    // Total number of boundaryFaces in DX mesh
    label totalNBfaces = nBfaces_ + nAddBfaces;

    // Total number of cells in DX mesh
    totalNCells_ = nOCells + nAddCells + totalNBfaces;

    // Set size of additional point addressing array
    addPointCellLabels_.setSize(nAddPoints);

    // Set size of addition cells mapping array
    superCells_.setSize(nAddCells);

    // Set size of addition faces patch mapping array
    superFacePatches_.setSize(nAddBfaces);

    // Set size of addition faces face mapping array
    superFaces_.setSize(nAddBfaces);

    // Create temporary storage for DX connections array vector
    int *bFacesArray = new int[nQuadPoints*totalNBfaces];

    // Create temporary storage for DX connections array vector
    int *cellsArray = new int[nHexPoints*totalNCells_];

    // Set counters for connections, additional points and cells
    label i = 0, api = 0, aci = 0;

    // Additional points start at the end of the points array
    label addPointi = nPoints();

    // Scan cells and build connections array
    forAll(cells, celli)
    {
        const cellModel& model = cells[celli].model();
        const labelList& shapeLabels = cells[celli];

        if (model == hex)
        {
            cellsArray[i++] = shapeLabels[0];
            cellsArray[i++] = shapeLabels[1];
            cellsArray[i++] = shapeLabels[3];
            cellsArray[i++] = shapeLabels[2];
            cellsArray[i++] = shapeLabels[4];
            cellsArray[i++] = shapeLabels[5];
            cellsArray[i++] = shapeLabels[7];
            cellsArray[i++] = shapeLabels[6];
        }
        else if (model == wedge)
        {
            cellsArray[i++] = shapeLabels[0];
            cellsArray[i++] = shapeLabels[1];
            cellsArray[i++] = shapeLabels[0];
            cellsArray[i++] = shapeLabels[2];
            cellsArray[i++] = shapeLabels[3];
            cellsArray[i++] = shapeLabels[4];
            cellsArray[i++] = shapeLabels[6];
            cellsArray[i++] = shapeLabels[5];
        }
        else if (model == prism)
        {
            cellsArray[i++] = shapeLabels[0];
            cellsArray[i++] = shapeLabels[1];
            cellsArray[i++] = shapeLabels[0];
            cellsArray[i++] = shapeLabels[2];
            cellsArray[i++] = shapeLabels[3];
            cellsArray[i++] = shapeLabels[4];
            cellsArray[i++] = shapeLabels[3];
            cellsArray[i++] = shapeLabels[5];
        }
        else if (model == pyr)
        {
            cellsArray[i++] = shapeLabels[0];
            cellsArray[i++] = shapeLabels[1];
            cellsArray[i++] = shapeLabels[3];
            cellsArray[i++] = shapeLabels[2];
            cellsArray[i++] = shapeLabels[4];
            cellsArray[i++] = shapeLabels[4];
            cellsArray[i++] = shapeLabels[4];
            cellsArray[i++] = shapeLabels[4];
        }
        else if (model == tet)
        {
            cellsArray[i++] = shapeLabels[0];
            cellsArray[i++] = shapeLabels[1];
            cellsArray[i++] = shapeLabels[0];
            cellsArray[i++] = shapeLabels[2];
            cellsArray[i++] = shapeLabels[3];
            cellsArray[i++] = shapeLabels[3];
            cellsArray[i++] = shapeLabels[3];
            cellsArray[i++] = shapeLabels[3];
        }
        else if (model == tetWedge)
        {
            cellsArray[i++] = shapeLabels[0];
            cellsArray[i++] = shapeLabels[1];
            cellsArray[i++] = shapeLabels[2];
            cellsArray[i++] = shapeLabels[2];
            cellsArray[i++] = shapeLabels[3];
            cellsArray[i++] = shapeLabels[3];
            cellsArray[i++] = shapeLabels[4];
            cellsArray[i++] = shapeLabels[4];
        }
        else if (model == splitHex)
        {
            cellsArray[i++] = shapeLabels[0];
            cellsArray[i++] = shapeLabels[1];
            cellsArray[i++] = shapeLabels[3];
            cellsArray[i++] = shapeLabels[2];
            cellsArray[i++] = shapeLabels[4];
            cellsArray[i++] = shapeLabels[5];
            cellsArray[i++] = shapeLabels[7];
            cellsArray[i++] = shapeLabels[6];
        }
        else
        {
            addPointCellLabels_[api++] = celli;
            cellShapeList cellTets = tetDecomposition(celli, addPointi++);

            const labelList& shapeLabels = cellTets[0];

            cellsArray[i++] = shapeLabels[0];
            cellsArray[i++] = shapeLabels[1];
            cellsArray[i++] = shapeLabels[0];
            cellsArray[i++] = shapeLabels[2];
            cellsArray[i++] = shapeLabels[3];
            cellsArray[i++] = shapeLabels[3];
            cellsArray[i++] = shapeLabels[3];
            cellsArray[i++] = shapeLabels[3];

            for (int j=1; j<cellTets.size(); j++)
            {
                superCells_[aci] = celli;

                label i = nHexPoints*(nOCells + aci++);

                const labelList& shapeLabels = cellTets[j];
                
                cellsArray[i++] = shapeLabels[0];
                cellsArray[i++] = shapeLabels[1];
                cellsArray[i++] = shapeLabels[0];
                cellsArray[i++] = shapeLabels[2];
                cellsArray[i++] = shapeLabels[3];
                cellsArray[i++] = shapeLabels[3];
                cellsArray[i++] = shapeLabels[3];
                cellsArray[i++] = shapeLabels[3];
            }
        }
    }


    // Reset cells connection counter to start after the additional cells
    i = nHexPoints*(nOCells + nAddCells);

    // Create a boundary face connection counter
    label bi = 0;

    // Set additional face counter
    label afi = 0;

    // Scan patches and build connections (Note: faces are converted into hexes)
    forAll (patches, patchi)
    {
        const polyPatch& faces = patches[patchi];

        if (valid(faces))
        {
            for (int facei=0; facei<faces.size(); facei++)
            {
                const labelList& shapeLabels = faces[facei];

                switch(shapeLabels.size())
                {
                    case 4:  // quad
                    {
                        cellsArray[i++] = shapeLabels[0];
                        cellsArray[i++] = shapeLabels[1];
                        cellsArray[i++] = shapeLabels[3];
                        cellsArray[i++] = shapeLabels[2];
                        cellsArray[i++] = shapeLabels[0];
                        cellsArray[i++] = shapeLabels[1];
                        cellsArray[i++] = shapeLabels[3];
                        cellsArray[i++] = shapeLabels[2];

                        bFacesArray[bi++] = shapeLabels[0];
                        bFacesArray[bi++] = shapeLabels[1];
                        bFacesArray[bi++] = shapeLabels[3];
                        bFacesArray[bi++] = shapeLabels[2];
                    }
                    break;

                    case 3:  // tri
                    {
                        cellsArray[i++] = shapeLabels[0];
                        cellsArray[i++] = shapeLabels[1];
                        cellsArray[i++] = shapeLabels[0];
                        cellsArray[i++] = shapeLabels[2];
                        cellsArray[i++] = shapeLabels[0];
                        cellsArray[i++] = shapeLabels[1];
                        cellsArray[i++] = shapeLabels[0];
                        cellsArray[i++] = shapeLabels[2];

                        bFacesArray[bi++] = shapeLabels[0];
                        bFacesArray[bi++] = shapeLabels[1];
                        bFacesArray[bi++] = shapeLabels[0];
                        bFacesArray[bi++] = shapeLabels[2];
                    }
                    break;

                    default:
                    {
                        cellsArray[i++] = shapeLabels[0];
                        cellsArray[i++] = shapeLabels[1];
                        cellsArray[i++] = shapeLabels[0];
                        cellsArray[i++] = shapeLabels[2];
                        cellsArray[i++] = shapeLabels[0];
                        cellsArray[i++] = shapeLabels[1];
                        cellsArray[i++] = shapeLabels[0];
                        cellsArray[i++] = shapeLabels[2];

                        bFacesArray[bi++] = shapeLabels[0];
                        bFacesArray[bi++] = shapeLabels[1];
                        bFacesArray[bi++] = shapeLabels[0];
                        bFacesArray[bi++] = shapeLabels[2];

                        for (int j=2; j<shapeLabels.size()-1; j++)
                        {
                            superFacePatches_[afi] = patchi;
                            superFaces_[afi] = facei;

                            label i =
                                nHexPoints
                               *(nOCells + nAddCells + nBfaces_ + afi++);

                            cellsArray[i++] = shapeLabels[0];
                            cellsArray[i++] = shapeLabels[j];
                            cellsArray[i++] = shapeLabels[0];
                            cellsArray[i++] = shapeLabels[j+1];
                            cellsArray[i++] = shapeLabels[0];
                            cellsArray[i++] = shapeLabels[j];
                            cellsArray[i++] = shapeLabels[0];
                            cellsArray[i++] = shapeLabels[j+1];

                            bFacesArray[bi++] = shapeLabels[0];
                            bFacesArray[bi++] = shapeLabels[j];
                            bFacesArray[bi++] = shapeLabels[0];
                            bFacesArray[bi++] = shapeLabels[j+1];
                        }
                    }
                    break;
                }
            }
        }
    }


    // Create array objects for cell connections
    // -----------------------------------------
    DXArray dxCellCons = DXNewArray(TYPE_INT, CATEGORY_REAL, 1, nHexPoints);

    if (!DXAddArrayData(dxCellCons, 0, totalNCells_, cellsArray))
    {
        DXSetError
        (
            ERROR_INTERNAL,
            "dxFoamExec:dxFvMesh::createDxConnections : Error in DXAddArrayData"
        );

        delete cellsArray;

        return DXERROR;
    }

    delete cellsArray;

    if (!DXSetStringAttribute((Object)dxCellCons, "element type", "cubes"))
    {
        DXSetError
        (
            ERROR_INTERNAL,
            "dxFoamExec:dxFvMesh::createDxConnections : "
            "Error in DXSetStringAttribute element type"
        );
        return DXERROR;
    }

    if (!DXSetStringAttribute((Object)dxCellCons, "ref", "positions"))
    {
        DXSetError
        (
            ERROR_INTERNAL,
            "dxFoamExec:dxFvMesh::createDxConnections : "
            "Error in DXSetStringAttribute ref"
        );
        return DXERROR;
    }

    if (!DXSetStringAttribute((Object)dxCellCons, "dep", "connections"))
    {
        DXSetError
        (
            ERROR_INTERNAL,
            "dxFoamExec:dxFvMesh::createDxConnections : "
            "Error in DXSetStringAttribute dep"
        );
        return DXERROR;
    }


    // Create array objects for boundary face connections
    // --------------------------------------------------
    dxBfaceCons_ = DXNewArray(TYPE_INT, CATEGORY_REAL, 1, nQuadPoints);

    if (!DXAddArrayData(dxBfaceCons_, 0, totalNBfaces, bFacesArray))
    {
        DXSetError
        (
            ERROR_INTERNAL,
            "dxFoamExec:dxFvMesh::createDxConnections : Error in DXAddArrayData"
        );

        delete bFacesArray;

        return DXERROR;
    }

    delete bFacesArray;

    if (!DXSetStringAttribute((Object)dxBfaceCons_, "element type", "quads"))
    {
        DXSetError
        (
            ERROR_INTERNAL,
            "dxFoamExec:dxFvMesh::createDxConnections : "
            "Error in DXSetStringAttribute element type"
        );
        return DXERROR;
    }

    if (!DXSetStringAttribute((Object)dxBfaceCons_, "ref", "positions"))
    {
        DXSetError
        (
            ERROR_INTERNAL,
            "dxFoamExec:dxFvMesh::createDxConnections : "
            "Error in DXSetStringAttribute ref"
        );
        return DXERROR;
    }

    if (!DXSetStringAttribute((Object)dxBfaceCons_, "dep", "BFconnections"))
    {
        DXSetError
        (
            ERROR_INTERNAL,
            "dxFoamExec:dxFvMesh::createDxConnections : "
            "Error in DXSetStringAttribute dep"
        );
        return DXERROR;
    }


    return dxCellCons;
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

} // End namespace Foam

// ************************************************************************* //
