/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright held by original author
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at your
    option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM; if not, write to the Free Software Foundation,
    Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

\*---------------------------------------------------------------------------*/

#include "plasticityModel.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

namespace Foam
{

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

defineTypeNameAndDebug(plasticityModel, 0);

// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

plasticityModel::plasticityModel
(
    const volTensorField& gradDU,
    const volSymmTensorField& epsilon,
    const volSymmTensorField& sigma
)
:
    rheologyModel(sigma),
    gradDU_(gradDU),
    epsilon_(epsilon),
    plasticityModelCoeffs_(subDict(type() + "Coeffs")),
    beta_
    (
        IOobject
        (
            "beta",
            sigma.time().timeName(),
            sigma.db(),
            IOobject::READ_IF_PRESENT,
            IOobject::AUTO_WRITE
        ),
        sigma.mesh(),
        dimensionedScalar("0", dimless, 0)
    ),
    sigmaY_
    (
        IOobject
        (
            "sigmaY",
            sigma.time().timeName(),
            sigma.db(),
            IOobject::READ_IF_PRESENT,
            IOobject::AUTO_WRITE
        ),
        sigmaY()
    ),
    DEpsilonP_
    (
        IOobject
        (
            "DepsilonP",
            sigma.time().timeName(),
            sigma.db(),
            IOobject::READ_IF_PRESENT,
            IOobject::AUTO_WRITE
        ),
        sigma.mesh(),
        dimensionedSymmTensor("0", dimless, symmTensor::zero)
    )
{}


plasticityModel::~plasticityModel()
{}


// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

void plasticityModel::correct()
{
    rheologyModel::correct();

    volScalarField mu_ = mu();
    volScalarField lambda_ = lambda();

    const volSymmTensorField DEpsilon = 
        symm(gradDU_)
      + dimensioned<symmTensor>
        (
            "SMALL",
            dimless,
            symmTensor(SMALL, SMALL, SMALL, SMALL, SMALL, SMALL)
        );

    const volScalarField DEpsilonEq =
        sqrt((2.0/3.0)*magSqr(dev(epsilon_ + DEpsilon)))
      - sqrt((2.0/3.0)*magSqr(dev(epsilon_)));

    const volSymmTensorField DSigma = 
        2*mu_*(DEpsilon - DEpsilonP_) + I*(lambda_*tr(DEpsilon));

    const volSymmTensorField& oldSigma = sigma();

    const volScalarField oldSigmaEq = sqrt(1.5*magSqr(dev(oldSigma)));

    const volSymmTensorField sigma_ = sigma() + DSigma;

    const volScalarField sigmaEq = 
        sqrt(1.5*magSqr(dev(sigma_)))
      + dimensionedScalar("SMALL", dimPressure, SMALL);

    const volSymmTensorField devSigma = 
        dev(sigma_)
      + dimensioned<symmTensor>
        (
            "SMALL",
            dimPressure,
            symmTensor(SMALL, SMALL, SMALL, SMALL, SMALL, SMALL)
        );

    const volSymmTensorField DSigmaE = DSigma + 2*mu_*DEpsilonP_;

    const volScalarField sigmaEqE  = sqrt(1.5*magSqr(dev(oldSigma + DSigmaE)));

    const volScalarField DSigmaEqE = sqrt(1.5*magSqr(dev(DSigmaE)));


    // Update internal beta
    const scalarField& muI = mu_.internalField();

    const scalarField& lambdaI = lambda_.internalField();

    const scalarField& sigmaYI = sigmaY_.internalField();

    const symmTensorField& DEpsilonI = DEpsilon.internalField();

    const scalarField& DEpsilonEqI  = DEpsilonEq.internalField();

    const symmTensorField& oldSigmaI = oldSigma.internalField();

    const scalarField& oldSigmaEqI = oldSigmaEq.internalField();

    const symmTensorField& devSigmaI = devSigma.internalField();

    const symmTensorField& DSigmaEI = DSigmaE.internalField();

    const scalarField& sigmaEqEI  = sigmaEqE;

    const scalarField& DSigmaEqEI = DSigmaEqE;

    const scalarField& oldBetaI = beta_.oldTime().internalField();

    scalarField& betaI = beta_.internalField();

    forAll (betaI, cellI)
    {
        symmTensor curDEpsEPred = symmTensor::zero;

        if( (DEpsilonEqI[cellI] >= 0) && (oldBetaI[cellI] > SMALL) )
        {
            betaI[cellI] = 1.0;
            curDEpsEPred = symmTensor::zero;
        }
        else
        {
            betaI[cellI] = 0.0;
            curDEpsEPred = DEpsilonI[cellI];
 
            if
            ( 
                (DEpsilonEqI[cellI] >= 0)
             && (sigmaEqEI[cellI] >= sigmaYI[cellI])
            )
            {
                scalar C = sqr(oldSigmaEqI[cellI]) - sqr(sigmaYI[cellI]);
                scalar B = 3.0*(dev(oldSigmaI[cellI]) && dev(DSigmaEI[cellI]));
                scalar A = sqr(DSigmaEqEI[cellI]);
 
                scalar alpha = (-B + ::sqrt(B*B - 4*A*C))/(2*A);
 
                curDEpsEPred =
                    alpha/(2.0*muI[cellI])
                   *(
                        DSigmaEI[cellI] 
                      - (lambdaI[cellI]/(2*muI[cellI] + 3*lambdaI[cellI]))
                       *tr(DSigmaEI[cellI])*I
                    );
 
                betaI[cellI] =
                    1.0
                  - (devSigmaI[cellI] && curDEpsEPred)
                   /(devSigmaI[cellI] && DEpsilonI[cellI]);
            }
        }
 
        betaI[cellI] = max(betaI[cellI], 0.0);
        betaI[cellI] = min(betaI[cellI], 1.0);
    }

 
    // Update beta at boundary
    forAll(beta_.boundaryField(), patchI)
    {
        const scalarField& muPatch = mu_.boundaryField()[patchI];
        const scalarField& lambdaPatch = lambda_.boundaryField()[patchI];

        const scalarField& sigmaYPatch = sigmaY_.boundaryField()[patchI];

        const symmTensorField& DEpsilonPatch = 
            DEpsilon.boundaryField()[patchI];

        const scalarField DEpsilonEqPatch = DEpsilonEq.boundaryField()[patchI];

        const symmTensorField& sigmaPatch = sigma_.boundaryField()[patchI];

        const scalarField& sigmaEqPatch = sigmaEq.boundaryField()[patchI];

        const symmTensorField& devSigmaPatch = 
            devSigma.boundaryField()[patchI];

        const symmTensorField& DSigmaEPatch = DSigmaE.boundaryField()[patchI]; 

        const scalarField& sigmaEqEPatch = sigmaEqE.boundaryField()[patchI];

        const scalarField& DSigmaEqEPatch = DSigmaEqE.boundaryField()[patchI];

        const scalarField& oldBetaPatch = 
            beta_.oldTime().boundaryField()[patchI];

        scalarField& betaPatch = beta_.boundaryField()[patchI];
        
        forAll(betaPatch, faceI)
        {
            symmTensor curDEpsEPred = symmTensor::zero;

            if
            ( 
                (DEpsilonEqPatch[faceI] >= 0) 
             && (oldBetaPatch[faceI] > SMALL) 
            )
            {
                betaPatch[faceI] = 1;
                curDEpsEPred = symmTensor::zero;
            }
            else
            {
                betaPatch[faceI] = 0;
                curDEpsEPred = DEpsilonPatch[faceI];
 
                if
                ( 
                    (DEpsilonEqPatch[faceI] >= 0)
                 && (sigmaEqEPatch[faceI] >= sigmaYPatch[faceI]) 
                )
                {
                    scalar C = 
                        sqr(sigmaEqPatch[faceI]) 
                      - sqr(sigmaYPatch[faceI]);
                    scalar B = 
                        3.0*(dev(sigmaPatch[faceI])&&dev(DSigmaEPatch[faceI]));
                    scalar A = sqr(DSigmaEqEPatch[faceI]);

                    scalar alpha = (-B + ::sqrt(B*B-4*A*C))/(2*A);

                    curDEpsEPred = 
                        alpha/(2.0*muPatch[faceI])
                       *(
                            DSigmaEPatch[faceI]
                          - (
                                lambdaPatch[faceI]
                               /(2*muPatch[faceI] + 3*lambdaPatch[faceI])
                            )
                           *tr(DSigmaEPatch[faceI])*I
                        );

                    betaPatch[faceI] =
                        1.0 
                      - (devSigmaPatch[faceI] && curDEpsEPred)
                       /(devSigmaPatch[faceI] && DEpsilonPatch[faceI]);
                }
            }
 
            betaPatch[faceI] = max(betaPatch[faceI], 0.0); 
            betaPatch[faceI] = min(betaPatch[faceI], 1.0);
        }
    }
 
    // Update plastic strain increment
    scalar rf = 
        readScalar(plasticityModelCoeffs_.lookup("relaxationFactor"));

    volSymmTensorField newDEpsilonP = 
        4.5*beta_*mu_*(devSigma && DEpsilon)*devSigma
       /((Ep() + 3*mu_)*pow(sigmaEq, 2));

    DEpsilonP_ = rf*newDEpsilonP + (1.0 - rf)*DEpsilonP_;
}


void plasticityModel::updateYieldStress()
{
    volScalarField Ep_ = Ep();
    const volSymmTensorField& newSigma = sigma();
    const volScalarField sigmaEq = sqrt(1.5*magSqr(dev(newSigma)));

    const scalarField& EpI = Ep_.internalField();
    const scalarField& sigmaEqI = sigmaEq.internalField();
    scalarField& sigmaYI = sigmaY_.internalField();

    forAll(sigmaYI, cellI)
    {
        if(EpI[cellI] != 0)
        {
            if( sigmaEqI[cellI] > sigmaYI[cellI] )
            {
                sigmaYI[cellI] = sigmaEqI[cellI];

                Info << " Internal cell " << cellI 
                    << " Yield stress updated to Sy= "
                    << sigmaEqI[cellI] * 1.0E-06 << " MPa" 
                    << endl;
            }
        }
    }

    forAll(sigmaY_.boundaryField(), patchI)
    {
        const scalarField& EpPatch = Ep_.boundaryField()[patchI];
        const scalarField& sigmaEqPatch = sigmaEq.boundaryField()[patchI];
        scalarField& sigmaYPatch = sigmaY_.boundaryField()[patchI];

        forAll(sigmaYPatch, faceI)
        {
            if(EpPatch[faceI] != 0)
            {
                if(sigmaEqPatch[faceI] > sigmaYPatch[faceI])
                {
                    sigmaYPatch[faceI] = sigmaEqPatch[faceI];

                    Info << "Boundary cell " << patchI << " " << faceI
                        << " Yield stress updated to Sy= "
                        << sigmaEqPatch[faceI] * 1.0E-06 << " MPa" 
                        << endl;
                }	
            }
        }
    }	
}


bool plasticityModel::read()
{
    if (regIOobject::read())
    {
        return true;
    }
    else
    {
        return false;
    }
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

} // End namespace Foam

// ************************************************************************* //
