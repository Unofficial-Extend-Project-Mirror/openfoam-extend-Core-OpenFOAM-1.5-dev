binaryTreeClean.C:    PtrList<binaryNode>& nodeList
binaryTreeClean.C:    forAll(nodeList, nodei)
binaryTreeClean.C:        if(nodeList[nodei].elementLeft_ != NULL)
binaryTreeClean.C:            if(nodeList[nodei].elementLeft_->nUsed() <= nLessUsed)
binaryTreeClean.C:                nLessUsed = nodeList[nodei].elementLeft_->nUsed();
binaryTreeClean.C:                Info << nodeList[nodei].elementLeft_->v0() << endl;
binaryTreeClean.C:                Info << nodeList[nodei].elementLeft_->nUsed() << endl;
binaryTreeClean.C:        if(nodeList[nodei].elementRight_ != NULL)
binaryTreeClean.C:            if(nodeList[nodei].elementRight_->nUsed() <= nLessUsed)
binaryTreeClean.C:                nLessUsed = nodeList[nodei].elementRight_->nUsed();
binaryTreeClean.C:                Info << nodeList[nodei].elementRight_->v0() << endl;
binaryTreeClean.C:                Info << nodeList[nodei].elementRight_->nUsed() << endl;
binaryTreeClean.C:        Info  << "value RIGHT "<< nodeList[nodeLessUsed].elementRight_->v0() << endl;
binaryTreeClean.C:        return *nodeList[nodeLessUsed].elementRight_;
binaryTreeClean.C:        Info << "value LEFT " << nodeList[nodeLessUsed].elementLeft_->v0() << endl;
binaryTreeClean.C:        return *nodeList[nodeLessUsed].elementLeft_;
binaryTreeClean.C:    PtrList<binaryNode>& nodeList
binaryTreeClean.C:    forAll(nodeList, nodei)
binaryTreeClean.C:        if(nodeList[nodei].elementLeft_ != NULL)
binaryTreeClean.C:            if(nodeList[nodei].elementLeft_->nUsed() <= nLessUsed)
binaryTreeClean.C:                nLessUsed = nodeList[nodei].elementLeft_->nUsed();
binaryTreeClean.C:                Info << nodeList[nodei].elementLeft_->v0() << endl;
binaryTreeClean.C:                Info << nodeList[nodei].elementLeft_->nUsed() << endl;
binaryTreeClean.C:        if(nodeList[nodei].elementRight_ != NULL)
binaryTreeClean.C:            if(nodeList[nodei].elementRight_->nUsed() <= nLessUsed)
binaryTreeClean.C:                nLessUsed = nodeList[nodei].elementRight_->nUsed();
binaryTreeClean.C:                Info << nodeList[nodei].elementRight_->v0() << endl;
binaryTreeClean.C:                Info << nodeList[nodei].elementRight_->nUsed() << endl;
binaryTreeClean.C:        Info  << "value RIGHT "<< nodeList[nodeLessUsed].elementRight_->v0() << endl;
binaryTreeClean.C:        return *nodeList[nodeLessUsed].elementRight_;
binaryTreeClean.C:        Info << "value LEFT " << nodeList[nodeLessUsed].elementLeft_->v0() << endl;
binaryTreeClean.C:        return *nodeList[nodeLessUsed].elementLeft_;
binaryTreeClean.C:    Info << "Cleaning Chemistry Library: number of nodes " << nodeList_.size() << endl;
binaryTreeClean.C:    forAll(nodeList_, nodeI)
binaryTreeClean.C:        nodeList_[nodeI].clearData();
binaryTreeClean.C:    nodeList_.clear();
binaryTreeInsert.C:        chemPoint &p = findLessUsed(nodeList_);
binaryTreeInsert.C:        label m = nodeList_.size();
binaryTreeInsert.C:        nodeList_.setSize(m+1);
binaryTreeInsert.C://        nodeList_.hook(new binaryNode(t->elementLeft(), NULL, NULL, NULL, NULL));
binaryTreeInsert.C:        nodeList_.hook(new binaryNode(NULL, NULL, NULL, NULL, NULL));
binaryTreeInsert.C:        binaryNode* node = &nodeList_[m];
binaryTreeInsert.C://        chemPointList_.hook(new chemPoint(x,&nodeList_[m]));
binaryTreeInsert.C://        binaryNode* node = &nodeList_[m];
binaryTreeInsert.C://        node->elementLeft_->node_ = &nodeList_[m];
binaryTreeInsert.C://        node->elementRight_->node_ = &nodeList_[m];
binaryTreeInsert.C:        chemPoint &p = findLessUsed(nodeList_);
binaryTreeInsert.C:        label m = nodeList_.size();
binaryTreeInsert.C:        nodeList_.setSize(m+1);
binaryTreeInsert.C:        nodeList_.hook(new binaryNode(NULL, NULL, NULL, NULL, NULL));
binaryTreeInsert.C:        binaryNode *node = &nodeList_[m];
binaryTreeInsert.C://        chemPointList_.hook(new chemPoint(x,&nodeList_[m]));
binaryTreeInsert.C://        chemPointList_[n].node_ = &nodeList_[m];
binaryTreeInsert.C://        binaryNode *node = &nodeList_[m];
binaryTreeInsert.C://        node->elementLeft_->node_ = &nodeList_[m];
binaryTreeInsert.C://        node->elementRight_->node_ = &nodeList_[m];
binaryTreeScan.C:    forAll(nodeList_,nodei)
binaryTreeScan.C:        if(nodeList_[nodei].elementLeft_ !=NULL)
binaryTreeScan.C:            Info << "nodeList_["<< nodei << "].elementLeft_() =" << nodeList_[nodei].elementLeft_->v0() << endl;
binaryTreeScan.C:            if(nodeList_[nodei].elementLeft_->node_ ==NULL)
binaryTreeScan.C:                Info << "nodeList_["<< nodei << "].elementLeft_() = " << nodeList_[nodei].elementLeft_->v0() << " doesn't point to any node" << endl;
binaryTreeScan.C:        if(nodeList_[nodei].elementRight_ !=NULL)
binaryTreeScan.C:            Info << "nodeList_["<< nodei << "].elementRight_() =" << nodeList_[nodei].elementRight_->v0() << endl;
binaryTreeScan.C:            if(nodeList_[nodei].elementRight_->node_ ==NULL)
binaryTreeScan.C:                Info << "nodeList_["<< nodei << "].elementRight_() =" << nodeList_[nodei].elementRight_->v0() << " doesn't point to any node" << endl;            }
binaryTree.H:        PtrList<binaryNode> nodeList_;
binaryTree.H:        chemPoint& findLessUsed(PtrList<binaryNode>& nodeList);
binaryTree.H:        chemPoint& findLessUsed(const chemPoint& p, PtrList<binaryNode>& nodeList);
